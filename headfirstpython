lists
Modules of Functions
Errors
Data


pyenv tools switch between python 2.7 and python 3

chapter 1
create simple python lists

movies = ["The Holy Grail", "The Life of Brain", "The Meaning of Life"]

(string, comma, square brackets, assign)

Python variable identifiters don't have a type
Identifiers are simply names that refer to a data object of some type.

Lists are like arrays:
when you create a list in python, the interpreter creates an array-like data
structure in memory to hold your data, with your data items stacked from the
bottom up. the first slot in the stack is numbered 0.

movies[1]   access list data using the square bracket notation

len(cast) return the length of a list

listname.append("new element")
listname.pop()
listname.extend(["",""])
listname.remove("")
listname.insert(0, "")

listname.insert(1, 1975)   insert year

Iterate:
for each_item in lists:
    print(each_item)

count = 0
while count < len(movies):
    print(movies[count])
    count = count + 1

you can use single quotes or double quotes with string
escape \"

Names can start with a letter character or an underscore, then include any
number of letter characters, numbers, and/or underscores in the rest of the
name. Strange characters (such as %$) are not allowed and you'll obviously want
to use names that have meaning within the context of your code.

python is case sensitive

Store lists within lists
Lists can hold data of mixed type.

Check a list for a list:
Each time you process an item in your list, you need to check to see if the
item is another list.
isinstance() lets you check if a specific identifier holds data of a specific
type.

names = ['michael', 'terry']
isinstance(names, list)   true

nums_names = len(names)
isinstance(num_names, list)   false

dir(__builtins__) to see a list of the build-in stuff that comes with python.

help(input)
help(isinstance)


Don't repeat code; create a function
def -- providing a name for your function and specifying either an empty or
populated argument list within parentheses. 

def function_name (arguments):
    function code suite

Recursion to the rescure!


Chapter 2 Modules of functions
Reusable code is great, but a shareable module is better.
how to create, install, and distribute your own shareable modules.

Modules let you orgnize your code for optimal sharing
The distribution utilites let you share your modules with the world

Turn your function into a module
A module is simply a text file that contains Python code. The main reuirement
is that the name of the file needs to end in .py: the Python extension. To turn
your function into a module, save your code into an appropriately named file:

Go ahead and create a text file called nester.py that contains your function
code from the end of chapter 1.

The Python Package Index (or PyPI for short) provides a centralized repository
for third-party Python modules on the Internet. When you are ready, you'll be
PyPI to publish your module and make your code available for use by others. And
your module is ready, but for one important addition.

Comment your code
"""
comment
"""
the triple quote for multiple-line comments.

# for one line comment

import sys
sys.path()

impirt nester
or from nester import print_lol
namespace different

Data is external to your program:
Most of your programs conform to the input-process-output model: data comes in,
gets manipulated, and then is stored, displayed, printed, or transferred.


How does Python read data from a file?
It's all lines of text
The basic input mechanism in Python is line based: when read into your program
from a text file, data arrives one line at a time.

Python's open() BIF lives to interact with files. When combined with a for
statement, reading files is straightforward.

When you use the open() BIF to access your data in a file, an iterator is
created to feed the lines of data from your file to your code one line at a
time.

the_file = open('sketch.txt')
the_file.close()


******
import os
os.getcwd()
'/Users/barryp/Documents'
os.chdir('../HeadFirstPhthon/chapter3')
os.getcwd()
'/Users/barryp/HeadFirstPython/chapter3'
******

use readline() method to grab a line from the file,
data = open('sketch.txt')
print(data.readline(), end='')
data.close()

split()
each_line.split(":")
"Man: Is this the right room for an argument?"
(role, line_spoken) = each_line.split(":")

print(role, end='')
print(' said: ', end='')
print(line_spoken, end='')

.split(':', 1)
each_line.find(':')

Try the code first. Then deal with errors as they happen.
Try first, then recover

Rather than adding extra code and logic to guard against bad things happening,
Python's exception handling mechanism lets the error occur, spots that it has
happened, and then gives you an opportunity to recover.


try:
    your code (which might cause a runtime error)
except:
    your error-recovery code

It turns out that there are two types of list in Python: those that can change
(enclosed in squre brackets) and those that cannot be changed once they have
been created (enclosed in regular brackets). The latter is an immutable list,
more commonly referred to as a tuple. Think of tuples as the same as a list,
except for one thing: once created, the data they hold cannot be changed under
any circumstances. Another way to think about tuples is to consider them to be
a constant list. 


data = open('sketch.txt')
for each_line in data: 
    try:
        (role, line_spoken) = each_line.split(':', 1) print(role, end='')
        print(' said: ', end='')
        print(line_spoken, end='')
    except: 
        pass
data.close()

Now, no matter what happens when the split() method is invoked, the try
statement catches any and all exceptions and handles them by ignoring the error
with pass.

import os
if os.path.exists('sketch.txt'):
    ***
else:
    ***

As the list of errors that you have to worry about grows, the complexity of the
"add extra code and logic" solution increase to the point where it starts to
obscure the actual purpose of the program.

By using Python's exception-handling mechanism, you get to concentrate on what
your code needs to do, as opposed to worrying about what can go wrong and
writing extra code to avoid runtime errors.

Prudent use of the try statement leads to code that is easier to read, easier
to write, and --perhaps most important -- easier to fix when something goes
wrong.

Although it is great to be able to handle all runtime errors, it's probably
unwise to be too generic... you will want to know if something other than an
IOError or ValueError occurs as a result of your code executing at runtime.

You need to somehow use except in a less generic way.


If your exception-handling code is designed to deal with a specific type of
error, be sure to specify the error type on the except line. In doing so,
youill take your exception handling code from generic to specific

except IOError:

python seek() method can be used to "rewind" a file to the beginning.


